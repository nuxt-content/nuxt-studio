---
title: Manage and integrate Medias in Nuxt Content Studio CMS
description: Explore how to browse and manage media files, including external storage with Cloudflare R2, and integrate them into your projects.
navigation:
  title: Media Library
  icon: i-lucide-image
seo:
  title: Nuxt Studio Media Library and External Storage
  description: Learn how to manage media files in Nuxt Studio, including external storage integration with Cloudflare R2 and other S3-compatible providers.
---

## Browse

All medias located in the `/public` directory are available in the **Media** tab of the Studio interface.

It's an intuitive interface for non technical users to manage their `/public` directory.

Users can easily browse folders, upload new media at any level, and drag and drop media, making medias organization straightforward.

The interface is designed to be intuitive for non-technical users. It can be viewed as a user friendly IDE.

## Editor integration

The TipTap visual editor provides seamless media integration:

- **Drag and drop** - Simply drag and drop images directly into the editor. An upload modal will open to let you choose the destination folder :badge[Coming Soon]
- **Slash commands** - Type `/` and search for `Image` to quickly insert a media. A modal will open to let you choose the media from your library
- **Alt text support** - From the media modal, you can set the [alt attribute](https://www.w3schools.com/tags/att_img_alt.asp) for SEO and accessibility
- **Attributes support -** From the media modal, you can set additional attributes like width, height, and custom properties for advanced use cases.

## Storage Comparison

| Feature          | Default             | External Storage        |
| ---------------- | ------------------- | ----------------------- |
| Setup            | Zero configuration  | Requires endpoint setup |
| Storage location | `/public` directory | External bucket         |
| Git commits      | Files committed     | Only URLs referenced    |
| Repository size  | Grows with media    | Stays small             |
| Best for         | Small projects      | Large media librariesD  |

## Default storage (`public` folder)

By default, media files are stored in your `/public` directory and committed to Git when you publish. This works great for most projects.

**Supported Types:**

- **Images**: JPEG, PNG, GIF, WebP, AVIF, SVG
- **Videos**: MP4, WebM

## External Storage (OSS)

For larger projects or teams with many media files, you can configure **external storage** to upload files to an Object Storage Service (OSS) like Cloudflare R2, AWS S3, or any S3-compatible provider.

External storage keeps your Git repository lean by uploading media files to a cloud storage provider instead of committing them to your repository.

::note
Files uploaded to external storage are **not committed to Git**. They are stored permanently in your cloud provider and referenced by URL in your content.
::

### Configuration

Enable external storage by adding the `media` option to your Studio configuration:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  studio: {
    media: {
      external: true,
      maxFileSize: 10 * 1024 * 1024, // 10MB
      allowedTypes: ['image/*', 'video/*', 'audio/*']
    }
  }
})
```

| Option         | Type       | Default                             | Description                              |
| -------------- | ---------- | ----------------------------------- | ---------------------------------------- |
| `external`     | `boolean`  | `false`                             | Enable external storage uploads          |
| `maxFileSize`  | `number`   | `10485760`                          | Maximum file size in bytes (10MB)        |
| `allowedTypes` | `string[]` | `['image/*', 'video/*', 'audio/*']` | Allowed MIME types (wildcards supported) |

### Implementation

You need to create three server endpoints that handle file operations with your storage provider.

::warning
All endpoints should verify the user has a valid Studio session before processing requests.
::

#### **Upload**

Receives files via multipart form data and uploads them to your storage provider.

```ts [server/api/studio/medias/upload.post.ts]
export default defineEventHandler(async (event) => {
  // 1. Verify user authentication (check Studio session)

  // 2. Parse multipart form data
  //    - 'file': the uploaded file (Buffer)
  //    - 'parentFsPath': the folder path in media library (e.g., '/images/blog')

  // 3. Validate the file
  //    - Check file size against your limit
  //    - Verify MIME type is allowed

  // 4. Generate a unique storage key
  //    - Include parentFsPath encoded in key for folder organization
  //    - Example: studio/images__blog/1234567890-abc123.jpg

  // 5. Upload to your storage provider

  // 6. Return the response
  return {
    success: true,
    data: {
      url: 'https://cdn.example.com/studio/...',  // Public URL
      filename: 'original-name.jpg',               // Original filename
      mimeType: 'image/jpeg',                      // MIME type
      size: 123456,                                // File size in bytes
      metadata: {
        key: 'studio/...',                         // Storage key (for deletion)
        parentFsPath: '/images/blog'               // Original folder path
      }
    }
  }
})
```

#### **List**

Returns all files from your storage provider for the media library.

```ts [server/api/studio/medias/index.get.ts]
export default defineEventHandler(async (event) => {
  // 1. Verify user authentication

  // 2. Get pagination token from query params
  //    const { continuationToken } = getQuery(event)

  // 3. List files from your storage provider
  //    - Filter to 'studio/' prefix only
  //    - Support pagination for large buckets

  // 4. Map files to required format
  //    - Decode parentFsPath from storage key

  // 5. Return the response
  return {
    success: true,
    data: {
      files: [
        {
          key: 'studio/images__blog/...',   // Storage key
          url: 'https://cdn.example.com/...', // Public URL
          parentFsPath: '/images/blog',       // Decoded folder path
          size: 123456,                       // Optional: file size
          lastModified: '2024-01-01T...'      // Optional: modification date
        }
      ],
      isTruncated: false,                     // More files available?
      nextContinuationToken: '...'            // Token for next page
    }
  }
})
```

#### **Delete**

Deletes a file from your storage provider using the file path as a route parameter.

```ts [server/api/studio/medias/[pat\\].delete.ts]
export default defineEventHandler(async (event) => {
  // 1. Verify user authentication

  // 2. Get storage key from route parameter
  //    const key = getRouterParam(event, 'path')

  // 3. Validate the key for security
  //    - Must start with 'studio/' prefix
  //    - Must not contain '..' (path traversal)

  // 4. Delete from your storage provider

  // 5. Return the response
  return {
    success: true,
    data: {
      key: 'studio/...',
      deletedAt: '2024-01-01T...'
    }
  }
})
```

#### Error Response Format

When an operation fails, return an error response:

```ts
{
  success: false,
  error: {
    code: 'UPLOAD_FAILED',    // Error code
    message: 'File too large' // Human-readable message
  }
}
```

Common error codes: `UPLOAD_FAILED`, `FILE_TOO_LARGE`, `INVALID_TYPE`, `LIST_FAILED`, `DELETE_FAILED`

### Providers

This pattern works with any S3-compatible storage provider. Simply adapt the SDK and endpoint configuration.

Compatible providers include:

- **AWS S3** - Use AWS SDK with your region endpoint
- **DigitalOcean Spaces** - S3-compatible API
- **Backblaze B2** - S3-compatible endpoint available
- **MinIO** - Self-hosted S3-compatible storage

## Examples

### Cloudflare R2

Here's a complete example using Cloudflare R2. The same pattern works with any S3-compatible provider.

::steps{level="4"}
#### Create R2 bucket

1. Go to [Cloudflare Dashboard](https://dash.cloudflare.com) and navigate to R2
2. Create a new bucket (e.g., `my-studio-media`)
3. Enable public access or configure a custom domain
4. Create an API token with read/write permissions

#### Set env variables

```bash [.env]
R2_ACCOUNT_ID=your_account_id
R2_ACCESS_KEY_ID=your_access_key
R2_SECRET_ACCESS_KEY=your_secret_key
R2_BUCKET_NAME=my-studio-media
R2_PUBLIC_URL=https://pub-xxx.r2.dev
```

#### Install Dependencies

```bash [Terminal]
npm install @aws-sdk/client-s3
```

#### Implement Endpoints

See the [playground/docus](https://github.com/nuxt/studio/tree/main/playground/docus/server/api) folder for a complete Cloudflare R2 implementation with all three endpoints.
::

##
